1. Why is MVVM important? Which files represent Model, which files represent View, and which files represent ViewModel?
MVVM (Model-View-ViewModel) is important because it separates the User Interface (UI) from the business logic and data. This separation makes the app easier to test, maintain, and scale without breaking other components when changes are made.
- Model (Data Layer): Represents the data and business logic.
  Files: Movie.kt, MovieDao.kt, MovieDatabase.kt, MovieRepository.kt
- View (UI Layer): Displays the data and handles user interactions.
  Files: MainActivity.kt, activity_main.xml
- ViewModel: Acts as a bridge, fetching data from the Model and preparing it for the View.
  Files: MovieViewModel.kt

2. In Part 1, you implemented Data Binding, why is this more efficient than using the normal method?
Data Binding is more efficient because it allows the View (XML) to bind directly to the data source in the ViewModel. This eliminates the need for writing repetitive boilerplate code like findViewById in the Activity/Fragment to update UI elements, reducing the risk of NullPointerExceptions and making the code cleaner.

3. In Part 2, you implemented the Singleton Pattern, why is this important?
The Singleton Pattern is important for the Room Database because creating a database instance is very expensive in terms of resources. It ensures that only one instance of the database exists across the entire application and coordinates access from multiple threads, preventing race conditions and ensuring data validity.

4. In Part 2 & 3, you implemented the Repository Pattern, why is this important?
The Repository Pattern is important because it acts as a single source of truth for the data. It handles the logic of deciding whether to fetch data from the local database (Room) or the network (API). This synchronizes the data between the web service and local storage, enabling offline capabilities so the user can access the app even without an internet connection.

5. In part 3, you implemented the Worker Manager, is there another way to refresh your database with the latest data other than using Worker?
Yes, there are other ways to refresh the database, though they have different use cases:
- Lifecycle-Aware Coroutines: Fetching data in onStart or onResume using coroutines. This only updates data when the user opens the app.
- SwipeRefreshLayout: Allowing the user to manually pull down to refresh the data.
- AlarmManager: Scheduling tasks at exact times (less efficient for battery than WorkManager).
- JobScheduler: The older API for scheduling background jobs.
WorkManager is preferred here because it guarantees the work will run even if the app is closed or the device restarts.
